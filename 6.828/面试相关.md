- 创建子进程的过程：从env_free_list中取得进程控制块，然后给进程的页目录分配内存，初始化页目录（进程的内核地址部分），初始化进程控制块，比如进程id，父id，进程状态（就绪态），进程的RPL，开中断，上下文环境初始化为父亲的上下文环境
- 用户态下的页错误处理：用户程序的全局变量_pgfault_handler保存好页错误处理程序，给进程分配异常处理栈，调用系统调用初始化进程控制块中的\_pgfault_upcall。最后实现了执行完页错误处理程序之后返回页错误之前的状态的过程。由于此时处于用户态，那么使用ret指令来实现返回，并且不会切换栈，需要我们手动切换，也就是更改存好的esp，预留4字节保存返回地址eip。
- 发生页错误过程：进入内核态，对该进程的异常栈进行初始化，比如错误地址、进入内核态前的各种寄存器、eip、esp。最后设置进程控制块中保存的eip为页错误处理程序入口地址，esp为异常栈的地址。最后从内核态切换为用户态，那么就去执行页错误处理程序了，并且栈为异常栈。
- 进程切换：将当前进程设置为就绪态，将目标进程设置为运行态，更改页目录（CR3寄存器），恢复目标进程的环境，即用esp指向进程控制块中的上下文环境部分，依次pop，最后调用iret，pop出eip、cs、esp和ss
- 中断与异常基本框架：在内核初始化时初始化IDT表，每个中断向量48位，根据中断向量号，设置相应位置的中断向量入口地址和DPL，保存在IDTR中。发生中断时，通过中断向量号找到中断服务程序的入口地址，此时栈已经切换为内核栈，并且保存了ss,esp,eflags, cs,eip以及一个可选的error code。设置段寄存器为内核的数据段（ds和es），然后进入trap函数，trap函数将保存在内核栈中的进程上下问信息复制到进程控制块中，然后根据中断向量号执行相应程序。
- 为什么系统调用的DPL为3？因为进程在用户态下使用int 48指令来请求系统调用，此时CS的RPL为3，需要访问IDT中的系统调用入口程序地址。
- 系统调用虽然是统一入口，但是在调用时在eax里保存好系统调用的类型，最终通过eax来执行相应的系统调用程序。
- 物理内存管理：在内核程序的末尾处给页目录分配一个页、给pageInfo分配内存，初始化pageInfo链表结构，把已经分出去的内存的引用数标记为1。
- 虚拟内存和物理内存的映射：根据虚拟地址，找到页目录，在页目录中填上物理地址以及权限位。
- Boot Loader: 主要是将操作系统从实模式转化为保护模式，然后将内核写入内存，并且跳转到内核的入口地址
- Kernel: 设置页表，开始CR0，然后重定位以下转为虚拟高地址，在数据段开启一块内存为内核栈，之后进行初始化：CGA、串行接口、内存、进程、IDT.
- 新建文件：通过路径找到文件所在的目录，从目录中找一个空闲的File，返回这个File。
- 读、写文件：通过文件所对应的File结构以及偏移地址，找到对应的虚拟地址，然后将内容复制到buf中。
- FS进程的打开文件表中有文件id、File *，文件描述符指针、open mode。
- 打开文件：用户进程给FS进程共享一个页，包含文件名和open mode，然后在value中写入对文件进行的操作，以及一个共享页面，然后接收一个共享页作为打开文件描述符。FS进程根据寻找一个空闲的打开文件项，并且根据文件名找到文件的File，写入到打开文件中，然后发送文件描述符
- 读文件：共享页写入文件id和写的多少，FS进程在该共享页中写入值
- 可扩展哈希：一个目录和多个桶。优点：动态增长；缺点：如果数据分布不均匀，那么目录会无限增长
- lru_k：丢弃时，优先从访问次数不够K次的frame中选，选择呆的时间最长的，即第一个链表的表头。否则从第二个链表的表头删；访问时，如果该frame访问次数不够K那么位置不变，如果够了K，那么就插入到第二个链表的表尾部，如果访问之前就已经够K次了，那么就从第二个链表中删除，放入该表表尾部。
