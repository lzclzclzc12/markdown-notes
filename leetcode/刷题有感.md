# 刷题有感

## [155. 最小栈](https://leetcode.cn/problems/min-stack/)

- 如果一个数组在按顺序删除时，也能知道此时数组的最小值，那么就保存每个数组中每个元素（包括自己）前面的元素的最小值，那么就额外开辟O(n)的空间，存这些值，那么当我们顺序删除元素时，就能及时知道最小值了。

## [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

- 计算一个表达式的值：将中缀转为后缀那样解
- 如果有负数，那么减号和负号需要特别处理：符号一般形式为`-(a + b)` 和`(-a + b)` 和`(-(a + b))`
- 也就是负号前面要么没有东西，要么为`(`，此时在负号前添加0就好了

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

- 如果访问了某个节点，那么我们需要将这个节点放到尾部
- 如何以O(1)的时间访问到这个节点呢？用哈希表，哈希表的value指向了该节点
- 使用双向链表可以迅速实现节点的删除和插入
- **当时的错误思路**是：哈希表来存节点的key和value，使用单链表来存节点。这样插入删除的时间是O(n)。

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

- 链表排序，且空间复杂度要达到O(1)，那么就必须原地排序，并且不能有递归
- 如果是快速排序，需要递归
- 如果是自顶向下的归并排序，需要递归
- 如果是**自底向上的归并排序**，**不需要递归**，使用循环就可以实现
- 思路就是先把链表两头断开，然后合并

## 二分查找

- 首先确定`[l,r]`里存放的值的意义，比如我们要找目标值t，那么l和r在移动时必须不能丢掉t可能在的区域。

## [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

- 这个题无法用双指针的思路，双指针一个特点就是指针的移动方向固定，但是这个题中[i , j + 1] 可能比[i + 1 , j]大，所以双指针无法确定移动方向
- 暴力的思路是将所有的组合遍历，然后建立小顶堆，选择出k对最小组合，但是太慢了
- 暴力的思路没有利用好两个数组本身有序，有序的话最小的组合为[0,0]，最大组合为[n - 1 , m - 1]
- 本题的主要思路为维护好一个堆，**当我们选择第k个最小组合时，堆里一定保存有这样的组合**，那么我们怎么维护这个堆呢？
- 当我们从堆中选择一个组合[i,j]时，**由于连个数组为有序**，所以**下一个组合一定为下面中的一个**：[i+1,j]、[i,j+1]和堆里剩余的组合，那为什么不是堆里剩余组合(比如[x,y])的下一个组合[x+1,y]和[x,y+1]呢？因为[x,y]组合还未被选择，那么此时将[x+1,y]和[x,y+1]放入堆里，下一次选择的不可能是[x+1,y]和[x,y+1]，所以放不放没区别。反倒是[i+1,j]、[i,j+1]有可能被选中
- 所以我们先把[0,0]入堆，这是第1个最小组合，然后将[0,1]和[1,0]入堆,.....，直到选择出k对
- 但是这样会出现重复，比如[i,j]把[i + 1 , j]和[i , j + 1] 入堆，然后[i+1,j-1]又将[i+1,j]入堆，这样[i+1 ,  j]出堆两次
- 最简单的思路是用哈希表来保存是否访问过
- 不用哈希的思路为：**[i,j]只入[i,j+1]，[i+1,j]由[i+1,j-1]入**，这样可以保证堆的正确性，因为如果[i+1,j-1]在堆中，那么下一个组合不会是[i+1,j]，如果[i+1,j-1]不在堆中，分两种情况，一种是[i+1,j-1]已经从堆中出来了，那么[i+1,j]一定已经在堆中了，不需要入堆；另一种是[i+1,j-1]还未入堆，那么下一个组合不会是[i+1,j]，不需要入堆。
- **但是[0,0]、[1,0]、... [n-1,0]没有组合可以入**，因为没有[1,-1],... [n-1 , -1]，所以初始化堆时可以把[0,0],... [n-1,0]入堆
- 当然我们如果[i,j]只入[i+1,j]不入[i,j+1]也是可以的，只不过初始化是[0,0],[0,1],....[0,m-1]入堆

## [172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)

- 本质是求[1,n]中因子为5的个数
- 那么[1,n]中有的数的因子可能有1个5，有的有2个5,.......
- 如果计算n / 5，那么得到的是至少有1个5的数的个数
- 计算(n / 5) / 5，那么得到的是至少有2个5的数的个数
- 依次类推

## [50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

- 这道题只想到了常规的一个一个乘，O(n)
- 但实际上：我们计算$x^n$，可以分解成计算$x^{n / 2} * x^{n / 2}$ 
- 那么我们就**每次计算一半的数**，时间复杂度为O(logn)
- 常规做法为O(n)，那么优化思路往O(logn)想，常见的O(logn)思路为**二分法**，比如二分查找，就是每次排除一般的数

